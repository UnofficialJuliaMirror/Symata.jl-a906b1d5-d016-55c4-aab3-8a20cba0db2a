* expr(3:4) does not always work
* If needs third branch

* Not true, or no longer:
  For instance cop = Count(_^2) defines a function that counts
  the number of arguments that have the form of a square.
  This does work: MatchQ( b^2, _^2)

* Reducing Times[]. When we get Infinity, we need to check for the numeric
  coefficient, so we can return DirectedInfinity[-1].
  How to do this efficiently ? We should probably compute the numeric part
  of the product as we do the analysis and then write a new array with only
  the non-numeric parts and work from there.  So, the entire procedure of
  removing numbers in sweeps will be replaced.

* Print sympy doc if no sjulia doc is available. Maybe even
  strip out the 'from sympyt import' part

* We can't disable infseval because it does some computation.

* Translation to and from SymPy is slow. For `Integrate' this is
usually not a problem. But, manipulation (eg Expand) of large expressions
may be hundreds of times faster in SymPy than the translation of the
result.

* [m, n] = [n, Mod(m, n)] Destructuring assignment

* gensyms that escape from Module can't be entered (parsed) at command line because of comment
 chars. Mma gensyms can be entered.  We need LModule only to remove temporary symbols. But,
 returned gensym symbols are entered again into the symbol table, with no special attributes.
  Mma gives gensyms attribute 'Temporary' and removes them when they go out of scope.
  We shouls use a separate gensym counter for SJulia, eg. $ModuleNumber.

* For 'Contexts', (like Julia modules), we should use ::, because the parser deals with it. Or '.',
  which is waht Julia uses for modules.  Back tick will not work.
  

* expr(3:4) does not always work

* We can't disable infseval because it does some computation.

* Translation to and from SymPy is slow. For `Integrate' this is
usually not a problem. But, manipulation (eg Expand) of large expressions
may be hundreds of times faster in SymPy than the translation of the
result.

* [m, n] = [n, Mod(m, n)] Destructuring assignment

* gensyms that escape from Module can't be entered (parsed) at command line because of comment
 chars. Mma gensyms can be entered.  We need LModule only to remove temporary symbols. But,
 returned gensym symbols are entered again into the symbol table, with no special attributes.
  Mma gives gensyms attribute 'Temporary' and removes them when they go out of scope.
  We should use a separate gensym counter for SJulia, eg. $ModuleNumber.

* For 'Contexts', (like Julia modules), we should use ::, because the parser deals with it. Or '.',
  which is waht Julia uses for modules.  Back tick will not work.
  
* Give exact values for CosD

* need a system for including packages and the associated sjulia capability only
 if the module is installed (or available)
 
* 'Do' with invalid iterator raises error. It shold warn and return unevaluated form.

* Allow user to set max number of mevals.

* Module should convert single line to compound expression.

* Getting error message "PyObject call" instead of unevaluated
 expression for, eg Integrate(x + c). Probably has to do
 with changing the REPL parsing code.

*  The result here should be simplified
   zz(aa(x_)) ^= x^2
   sjulia > zz(aa(3))
   3 ^ 2

*  Use this test, or example. h([x_,y_]) := x^y

* Make Void meval to Null (better yet, avoid Void)

* Error messages have become shorter and more cryptic. Why
  e.g MethodError(SJulia._do_Comparison,(ex,==,((-1 + x) ^ 2) * (1 + 2 * x + 2 * (x ^ 2) + x ^ 3)))
  when comparing unbound symbol to polynomial


------------------------------------------------------------------

 ===  DONE ===

*  Fixed. at least we get one level of subexpressions by calling mergeargs in sympy.jl
   Cos(Pi/6) returns unevaluated. Fix this, or use Sympy instead
   But, enabling the sympy version causes the dirty symbol test in
   evaluation_test.jl to fail. Sin will fail dirty symbol test because
   it is done by SymPy.


* When sum is unbound , we get this:
sjulia > Do( sum += i, [i,[1,2,3,4,5]])
1 + sum
ERROR: Too many meval entries 201
 in eval(::Module, ::Any) at ./boot.jl:237
Mma gives this:
AddTo::rvalue: sum is not a variable with a value, so its value cannot be
     changed.

* If needs third branch

* Allow multiline input at sjulia prompt (or from file ??) julia mode already
 does allow this. Check if parsed string returns Expr with head :incomplete


* Print sympy doc if no sjulia doc is available. Maybe even
  strip out the 'from sympyt import' part

* Integrate( Exp(-t)*t^(a-1),[t,0,Infinity])  fails because it returns an expression with type Base.#<,
  no idea what this object is. We should convert it to SJulia comparison, of course.
  For the moment we print an error.

  Fixed, but resdesign should be considered
* Reducing Times[]. When we get Infinity, we need to check for the numeric
  coefficient, so we can return DirectedInfinity[-1].
  How to do this efficiently ? We should probably compute the numeric part
  of the product as we do the analysis and then write a new array with only
  the non-numeric parts and work from there.  So, the entire procedure of
  removing numbers in sweeps will be replaced.

* Not true, or no longer: *** Yes, this works, but only on a list,
  which is how Count works. But, we could do it on args of any function.
  For instance cop = Count(_^2) defines a function that counts
  the number of arguments that have the form of a square.
  This does work: MatchQ( b^2, _^2)

